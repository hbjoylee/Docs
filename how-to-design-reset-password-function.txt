密码找回设计
最后的方案: 

数字签名 = MD5(用户名+'$'+过期时间+密钥key) 

数据库字段(用户名(主键),密钥key,过期时间) 

url参数(用户名,数字签名) 

密钥key的生成：在每一个用户找回密码时候为这个用户生成一个密钥key 

然后生成过期时间,生成数字签名,生成url,发送邮件. 

saveOrUpdate(用户名,密钥key,过期时间) 

解析url：首先根据用户名从数据库中查找出密钥key和过期时间,没有则表示该请求 

是伪造的或者过期的,然后验证签名,验证过期时间,都验证通过,就可以修改密码, 

密码修改完以后,删除数据库中的记录。 

还需要加一个定时任务,删除数据库中当前时间大于过期时间的记录。 
连续发两次找回密码请求,到底在数据库是生产一条数据还是两条数据? 
一条数据貌似比较省事吧.
恩，这里用的是一条,保存数据库使用saveOrUpdate
没太清楚。 
我的构想如下： 
使用uuid随机生成一个key，然后把记录保存下来，包括过期时间之类的，统统存到数据库中。 

用户点击链接的时候，就用这个key去匹配就行了。至于URL中还要存几个参数，那就随你了。 

其实数据库中只要一条数据就行了，用userid进行匹配

以前实现过此功能，思路和这个类似。 
随便搞一长串的随机字符auth_key，有意义也好，没意义也好，总之要看（研究）不出来是啥，全局唯一（组合使用uuid、时间、机器特征、随机数等）。 
然后在db里有张表，用uid和这个auth_key关联，同时可以有过期时间的字段。 
同一个uid，只有一条记录。 
甚至可以有一个单独的程序（线程、进程）去扫描此表，过期的记录就删掉。 

给用户的url里带回那个auth_key，到db里查查有没有记录，过没过期，然后就可以让用户修改密码了。

可以改下修改密码的流程，不一定非得生成和解析URL。URL可以是个能否修改密码的锁。用户点击下邮箱里的URL，下次登录系统就提示他必须修改密码。修改一次后。该URL失效。可以删掉该URL。这样就不存在过期时间、集群和key的问题。


当我们设计一个带有用户注册/登录功能的网站的时候，一个必须的功能就是重设密码。 重设密码功能有很多种设计方式，比如发送一个新密码到用户邮箱等。不过今天我要介绍一个我经常用实现方式。

用户流程:
用户忘记密码，来到密码重设界面
用户输入Email地址，点击重设密码按钮
用户收到一封密码重设邮件，里面有重设密码的链接，此链接有过期时间
用户点击链接，来到密码重设页面，输入新密码，完成
这个流程并没有什么创新，很多网站都是用这套流程

后端实现方式:
当用户输入Email地址后，验证这个Email，如果存在于数据库，那么取得用户的user_id
将user_id和当前时间戳编码成HASH，需要提前准备好一个KEY，并且这个KEY只存在服务器上。  HASH = md5 ( user_id + timestamp + KEY )
生成一个URL，并且附带刚刚生成的HASH和用户id以及timestamp，比如 http://domain.com/reset-password.php?hash=HASH&user_id=123&timestamp=1392121211
当用户访问这个URL, 检查HASH是否合法: HASH == MD5 ( user_id + timestamp + KEY)
检查 timestamp 是不是过期了
如果所有检查通过，那么显示一个新密码表单给用户
这种方式的好处:
不需要额外的数据表
不用担心参数被用户恶意修改，因为要检查hash是不是等于那几个参数的md5
密码重设URL自带时间戳
只要KEY设置的足够长足够复杂，那么可以认为HASH是绝对安全的
更详细的样例代码可以参考这里： http://jszen.com/reset-password-system.6.html